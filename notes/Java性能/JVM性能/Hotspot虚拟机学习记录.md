# Hotspot垃圾收集原理

垃圾收集器自动管理应用程序的动态内存分配请求。

垃圾收集器通过以下操作执行自动动态内存管理：
1. 从操作系统分配内存并将内存返还给操作系统。
2. 根据应用程序的请求将该内存分发给应用程序。
3. 确定应用程序仍在使用该内存的哪些部分。
4. 回收未使用的内存以供应用程序重用。

HotSpot垃圾收集器采用各种技术来提高这些操作的效率：
1. 将分代清理与老化结合使用，将工作重点集中在堆中最有可能包含大量可回收内存区域的区域。
2. 使用多个线程积极地使操作并行，或在后台与应用程序并发执行一些长时间运行的操作。
3. 尝试通过压缩存活对象来恢复更大的连续可用内存。

对于一般的应用程序，它们可以在存在垃圾收集且暂停频率和持续时间适中的情况下良好地执行。然而，对于具有大量数据、多线程、高事务率的应用程序，GC可能成为关键问题。

![](../../images/cmp-percentage-of-time-spent-in-gc.png)

上图由Oracle提供，该图模拟了一个理想的系统，除了垃圾收集之外，该系统具有完美的可扩展性。红线是在单处理器系统上仅花费1%时间进行垃圾收集的应用程序。这意味着具有32个处理器的系统吞吐量损失超过20%。洋红色线显示，对于在垃圾收集中花费10%时间的应用程序（在单处理器应用程序中，垃圾收集时间不算太长），当扩展到32个处理器时，损失的吞吐量超过75%。<br>
该图表明，在小型系统上开发时可忽略的吞吐量问题可能会成为扩展到大型系统时的主要瓶颈。然而，减少这种瓶颈的小改进可以带来性能的巨大提升。对于足够大的系统，选择正确的垃圾收集器并在必要时对其进行调优是值得的。

Hotspot提供的垃圾回收器：
- Serial Collector
- Parallel Collector
- Garbage-First (G1) Garbage Collector
- The Z Garbage Collector

## Hotspot垃圾收集调优原则

Hotspot为垃圾收集器、堆大小、运行时编译器(JIT)提供与平台相关的默认选择。
- 服务器级计算机上默认采用G1收集器，其他计算机上默认采用串行收集器。（如果Hotspot检测到两个以上处理器且堆大小$≥$1792MB，则Hotspot会将当前计算机视为服务器级计算机上。）
- GC线程的最大数量受堆大小和可用CPU资源的限制。
- 初始堆大小默认为物理内存的1/64。
- 最大堆大小默认为物理内存的1/4。
- 分层即时编译器默认同时使用C1和C2。 

Hotspot的垃圾收集器会试图尽可能优化最长暂停时间或应用程序吞吐量。
- 暂停时间是垃圾收集器停止应用程序并回收不再使用的空间的持续时间。<br>垃圾收集器维护暂停时间的均值和方差，暂停时间的数据从执行开始时获取。计算均值时，较近的暂停拥有更高的权值。如果均值与方差之和$>$最大暂停时间限制，则垃圾收集器认为当前未满足最大暂停时间约束。<br>最大暂停时间约束由命令行选项`-XX:MaxGCPauseMillis=<nnn>`指定。垃圾收集器调整Java堆大小等垃圾收集相关参数，以尝试使垃圾收集暂停时间短于`<nnn>`毫秒。这些调整可能会导致垃圾收集更频繁地发生，从而降低应用程序的整体吞吐量。某些情况下，即使经过调整，也无法满足最大暂停时间约束。
