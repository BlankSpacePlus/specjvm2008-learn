# 系统性能

系统性能是对整个计算机系统性能的研究，包括主要硬件组件和软件组件。所有数据路径上和从存储设备到应用软件上所发生的事件都可能影响系统性能。

系统性能关注通过减少延时和降低计算成本来改善终端用户的体验。其中，降低计算成本可以通过消除低效部分、提高系统吞吐量、进行常规性能调优来实现。

系统性能需要多类人员参与，性能只是这些人员工作的一部分。对于某些性能问题，要找到根本原因或促成因素需要多个团队的协同工作。<br>
专业的性能工程师的主要任务就是维护系统性能。他们与多个团队协同工作，对环境做全局性的研究，执行一些对解决复杂性能问题至关重要的操作。此外，他们还可以帮助整个环境的性能分析和容量规划寻找和开发更好的工具。

系统性能工程是主观的、复杂的、多问题并存的。最重要的任务不是寻找性能问题，而是辨别性能问题、辨别哪些是最重要的性能问题。因此，性能分析必须量化不同性能问题的重要程度，预估每个性能问题修复后带来的性能增速。

系统性能模型：
- 受测系统模型：输入(工作负载)+扰动→性能结果
    - 扰动会影响性能结果。扰动的来源也是复杂且不明确的，定时执行的系统活动、系统重的其他用户活动、系统中的其他工作负载都可能是扰动的来源。
- 排队系统模型
    - 某些组件和资源可以模型化为排队系统。

## 性能负载

应用程序性能差可能是因为软件配置和硬件问题，也可能是由于负载太多导致的排队和长延时。

负载增加下的系统所展现出的性能称为可扩展性。在一定范围内，随着负载的增加，系统吞吐量近似于线性增长；当超出某个阈值后，工作负载的增加会导致资源争夺的进一步加剧，进而导致系统吞吐量偏离线性增长直至负增长。

# 系统性能指标

指标是为了评估或者监测一个目标而选择的统计数据。

性能指标是由系统、应用程序、其他工具而选择的统计数据，用于测量感兴趣的活动。<br>性能指标用于性能分析和检测，可以由命令行提供数据，也可以由可视化工具提供图表。

常见系统性能指标：
- IOPS：每秒发生的I/O操作的次数，用于度量数据传输率，单位是m、s、ms、μs、ns、ps。对于磁盘读写，IOPS指的是每秒读写次数。
- 吞吐量：工作执行的效率，用于度量数据传输速率，单位是b/s、B/s等。对于数据库的增删改查，吞吐量指的是操作的速度，单位是OP/s。
- 响应时间：完成一次操作的时间，包括用于等待和服务的时间、返回结果的时间。
- 延时：操作中用来等待服务的时间，操作执行前所花的等待时间。某些情景下，延时等同于响应时间。延时以平均数或百分比表示。
- 使用率：对于服务所请求的资源，使用率描述在给定时间区间内资源的繁忙程度；对于提供存储的资源来说，使用率描述所消耗的存储容量。使用率以百分比表示。
- 饱和度：随着工作量增加而对资源请求超过资源所能处理的程度，也可以指某一资源无法提供服务的工作的排队程度。
- 瓶颈：限制系统性能的资源。
- 工作负载：系统的输入或者对系统施加的负载。对于数据库的增删改查，工作负载指的是客户端发出的数据库请求和命令。
- 缓存：用于复制或缓冲一定量数据的高速缓存区域，以避免对较慢的存储层级的直接访问，从而提高性能。处于经济考虑，缓存区的容量要比更慢一级的存储容量小。

性能指标的数据采集不是无偿的，可能会消耗一些CPU周期来收集和保存指标信息。这些额外开销会对测量目标的性能带来负面影响(观察者效应)。

观测工具和构建在其上的统计都是由软件实现的，自然难以避免bug的存在。<br>
实际生产实践中，很多软件厂商提供的性能指标组合不见得是完美无瑕的，可能是混淆的、复杂的、不可靠的、不精确的、过时的、错误的。
- 工具和测量方法可能是错误的。
- man手册是不完整的。
- 可用的性能指标是不完整的。
- 可用的性能指标是易混淆的。
- 指标收集工具可能有bug。
- 指标处理过程存在bug。

可以用多个观测指标覆盖的观测工具互相检查，也可以施加已知的工作负载校验测量结果与预计结果是否一致，以判断观测工具是否存在明显bug。<br>
实际生产实践中，往往当遇到不寻常、不合理结果时才会这么做。

# 系统性能量化

量化系统性能的方法：
- 观测法
    1. 选择可靠的指标。
    2. 估计解决问题带来的性能收益。
- 实验法
    1. 实施性能修复。
    2. 用可靠的指标量化做前后对比。

# 性能分析

对软件栈分析时，主要的两个视角是负载分析和资源分析。系统管理员主要开展资源分析，应用程序开发者主要开展负载分析。

性能问题可能出现在任何地方，包括软件、硬件、数据路径上的各种组件。

系统的操作就是处理离散的时间，包括CPU指令、磁盘I/O、磁盘命令、网络包、系统调用、函数库调用、应用程序事务、数据库查询等。<br>
系统性能分析通常会研究这些事件的汇总数据，例如每秒的操作数、每秒的字节数、延时的均值等。

性能分析可以终止于以下情况：
- 当大部分性能问题已经被发现时。
- 当潜在的ROI(投资回报率)低于分析成本时。
- 当其他地方有更高的ROI时。

## 资源分析

常见的系统资源：
- CPU：插槽、核、硬件线程（虚拟CPU）
- 内存：DRAM
- 网络接口：以太网端口，无限带宽技术
- 存储设备：磁盘、存储适配器
- 加速器：GPU、TPU、FPGA等，如果用得到的话
- 控制器：存储、网络
- 互联：CPU、内存、I/O

常见的软件资源：
- 互斥锁：锁被持有的时间是使用率，饱和度指的是有线程排队在等待锁。
- 线程池：线程忙于处理工作的时间是使用率，饱和度指的是等待线程池服务的请求数目。
- 进程/线程数量：系统的进程或线程的总数是有上限的，当前的使用数目是使用率，等待分配的数目是饱和度，错误是分配失败。
- 文件描述符容量：同进程/线程容量一样，只不过针对的是文件描述符。

资源分析对以系统资源分析为起点。
- 性能问题研究：看是否是某特定类型资源的责任。
- 容量规划：为设计新系统提供信息，或者对系统资源何时会耗尽做预测。

适合资源分析的性能指标：
- IOPS
- 吞吐量
- 使用率
- 饱和度

操作系统层面的资源统计工具：
- vmstat(1)
- iostat(1)
- mpstat(1)

某些资源可能会因为碰到软件施加的限制而成为瓶颈。寻找负载下瓶颈资源的方法：
1. 测量服务器请求的频率，并监视请求频率随时间的变化。
2. 测量硬件和软件资源的使用，并监测使用率随时间的变化。
3. 用资源的使用来表示服务器的请求情况。
4. 根据每个资源来推断服务器请求的极限。

资源扩展方案：
- 水平扩展：用负载均衡器将负载分配到更多的系统中。
- 垂直扩展：用更强大的系统替换当前的系统。

## 负载分析

负载分析的对象：
- 请求：所施加的工作负载。
- 延时：应用程序的响应时间，是体现应用程序性能最重要的指标。
- 完成度：查找错误。

适合负载分析的性能指标：
- 吞吐量
- 延时

## 系统性能分析方法

BrendanGregg总结了如下性能分析方法：

| 分析方法 | 方法类型 |
|:----:|:----:|
| 用熟悉的观测工具、已有的经验开始尝试分析 | 观测分析 |
| 随机猜测问题可能出现的位置，做出改动直到问题解决 | 实验分析 |
| 让负责其他组件的团队各自分析相应的问题 | 假设分析 |
| 根据即时更新的目标清单逐一检查问题 | 观测分析、实验分析 |
| 询问问题并获得答案 | 信息收集 |
| 提出问题→作出假设→给出预测→验证猜测→分析总结 | 观测分析 |
| 假设→实验→数据→假设，强调数据快速引发新的假设 | 生命周期分析 |
| 选择所有可用工具，列出有用的指标，阐释该指标可能的规则 | 观测分析 |
| USE方法(查看所有资源的利用率、饱和度、错误) | 观测分析 |
| RED方法(检查每个服务的请求率、错误、持续时间) | 观测分析 |
| 工作负载特征归纳 | 观测分析、容量规划 |
| 自顶向下的分析方法，检测、识别、分析 | 观测分析 |
| 延时分析，对有较大延时的时间段继续划分 | 观测分析 |
| 针对Oracle数据库提出的R方法 | 观测分析 |
| 事件跟踪 | 观测分析 |
| 提供baseline标准数据用于对比 | 观测分析 |
| 静态性能调优 | 观测分析、容量规划 |
| 缓存调优 | 观测分析、调优 |
| 微基准测试 | 观测分析 |
| 排队理论 | 统计分析、容量规划 |
| 容量规划 | 容量规划、调优 |
| 量化性能收益 | 统计分析 |
| 监测 | 观测分析、容量规划 |

特殊领域的常见性能分析方法：
- Linux基础性能分析
- CPU剖析
- Off-CPU分析
- 周期分析
- 优先级调优
- 资源控制
- CPU绑定
- 泄漏检测
- 内存紧缩
- 磁盘分析
- 工作负载分离
- 容量扩展
- 包嗅探
- TCP分析
- 被动基准测试
- 自定义基准测试
- 逐渐增加负载
- 合理性检查

## Linux基础性能分析

平均负载可识别负载的增加或减少：
```shell
uptime
```

包括OOM事件的内核错误：
```shell
dmesg -T | tail
```

系统级统计：运行队列长度、交换、CPU总体使用情况
```shell
vmstat -SM 1
```

CPU平衡情况：单个CPU很繁忙，意味着线程扩展性糟糕
```shell
mpstat -P ALL 1
```

每个进程的CPU使用情况：识别意外的CPU消费者，以及每个进程的用户/系统CPU时间
```shell
pidstat 1
```

磁盘I/O统计：IOPS的吞吐量、平均等待时间、忙碌百分比
```shell
iostat -sxz 1
```

内存使用情况，包括文件系统的缓存：
```shell
free -m
```

网络设备I/O：数据包、吞吐量
```shell
sar -n DEV 1
```

TCP统计：连接率、重传
```shell
sar -n TCP,ETCP 1
```

检查概览
```shell
top
```

## 容量规划

容量规划可以检查系统处理负载的情况，以及系统如何随着负载的增加而扩展。

## 性能监测

系统性能监测记录一段时间内（一个时间序列）的性能统计数据，可以对过去的记录和现在的记录作比较，这样能够找出基于时间的使用规律。这对容量规划、量化增长、显示峰值都很有帮助。

| 监测工具类型 | 性能数据来源 |
|:----:|:----:|
| 进程级计数器 | `/proc` |
| 系统级计数器 | `/proc`、`/sys` |
| 设备配置与计数器 | `/sys` |
| cgroup统计 | `/sys/fs/cgroup` |
| 进程级跟踪 | `ptrace` |
| 硬件计数器(PMC) | `perf_event` |
| 网络统计 | `netlink` |
| 捕获网络数据包 | `libpcap` |
| 线程级延时指标 | 延时审计 |
| 系统级跟踪 | `Ftrace`、`tracepoint`、软件事件、`kprobes`、`uprobes`、`perf_event` |

# 性能调优

性能调优分为静态性能调优和动态性能调优。
- 静态性能调优关注架构配置问题。
- 动态性能调优关注负载施加后的性能。

性能调优试试在越靠近工作执行的地方效果越显著。

| 层级 | 调优对象 |
|:----:|:----:|
| 应用程序 | 应用程序逻辑、请求队列大小、执行的数据库请求 |
| 数据库 | 数据库表的布局、索引、缓冲 |
| 系统调用 | 内存映射或读写、同步或异步I/O标志 |
| 文件系统 | 记录大小、缓存大小、文件系统可调参数、日志 |
| 存储系统 | RAID级别、磁盘类型和树木、存储系统可调参数 |

计算机系统的性能特性会随着时间改变，用户的变化、硬件的变化、软件和固件的变化都可能引起系统性能特性的变化。性能调优的推荐范围只在某段时间内有效，不会长期有效。<br>
当改变可调参数时，把它们记录到有详细历史记录的版本控制系统中是非常有效的。

性能调优经验顺序：
1. 消除不必要的工作。
2. 缓存。
3. 调低刷新、轮询、更新的频率。
4. 回写缓存。
5. 安排工作或在非工作时间进行。
6. 从单线程切换到多线程。
7. 购买更快的硬件设备。

# 系统性能工具

给一个系统定位问题的时候，知识、经验是关键，数据是依据，工具是运用知识处理数据的手段。其中，工具永远都是知识技能的一层包装，没有什么工具是无所不能的。

观测工具和基准测试工具都可以用于确定系统性能。
- 对于闲置的测试环境，可以采用基准测试工具来确定系统性能。基准测试工具通过一系列工作负载实验来修改系统状态。
- 对于活跃的生产环境，建议先用可观测性工具来观测系统性能。可观测性工具包括计数器(counter)、剖析器(profiler)、追踪器(tracer)。
    - 计数器在软件中被硬编码，内核维护了各种提供系统统计数据的计数器。
        - 有的计数器总是递增的，可以用于计算操作计数、字节计数、延时测量、资源利用率、错误率。性能工具可以在不同的时间读取这些累计的计数器，从而计算出统计数据：随时间变化的比率、平均值、百分比等。
        - 计数器默认开启，使用计数器的开销可以忽略不计。计数器的额外开销来自从用户空间读取它们的时候，也可以忽略不计。
        - 系统级别的计数器：
            - `vmstat(8)`：统计虚拟内存和物理内存。
            - `mpstat(1)`：统计每个CPU的使用情况。
            - `iostat(1)`：统计每个磁盘I/O的使用情况，由块设备接口报告。
            - `nstat(8)`：统计TCP/IP栈。
            - `sar(1)`：统计全面的数据，能归档历史数据。
        - 进程级别的计数器：
            - `ps(1)`：进程状态，显示进程的各种统计信息，包括内存和CPU的使用。
            - `top(1)`：按一个统计数据(如CPU使用)排序，显示排名高的进程。
            - `pmap(1)`：将进程的内存段和使用统计一起列出。
    - 剖析器负责采样，取一个测量的子集(样本)来研究以描绘目标的粗略情况。
        - 剖析器常见的目标是CPU使用率，根据定时器采集指令的指针或栈踪迹的样本，来描绘CPU消耗的代码路径。
        - 剖析器采样的速率往往是固定的，在有限时间内按固定频率对所有CPU都采集一遍。剖析器的采样频率通常是99Hz，避免采样与目标活动同一步调而导致少算或多算。
        - 剖析器也能基于非计时的硬件事件，如CPU硬件缓存未命中或者总线活动。这种情况下，剖析器的结果可以显示出哪条代码路径是性能瓶颈，为开发人员优化代码提供依据。
        - 系统级别的剖析器：
            - `perf(1)`：Linux标准剖析器，包含剖析的子命令。
            - `profile(8)`：来自BCC代码库的基于BPF的CPU剖析器，在内核上下文对栈踪迹进行频率统计。
            - `Intel VTune Amplifier XE`：对Linux和Windows进行剖析，拥有包括源代码浏览在内的图形界面。
        - 进程级别的剖析器：
            - `groff(1)`：GNU剖析工具，其分析由编译器添加的剖析信息。
            - `cachegrind`：来自valgrind工具包的一个工具，可以对硬件缓存的使用情况进行剖析，并使用kcachegrind对剖析可视化。
            - `Java Flight Recorder (JFR)`：Java特殊用途的剖析器。
    - 追踪器捕获事件数据并保存起来供以后分析，或即时用于自定义总结等操作。
        - 静态检测描述的是添加到源代码中的硬编码的软件检测点。
        - 动态检测描述的是运行时通过修改内存指令插入检测程序的软件检测点。
        - 系统级别的追踪器：
            - `tcpdump(8)`：网络包跟踪（使用libpcap库）。
            - `biosnoop(8)`：块I/O跟踪（使用BCC或bpftrace）。
            - `execsnoop(8)`：新的进程跟踪（使用BCC或bpftrace）。
            - `perf(1)`：Linux标准剖析器，也能跟踪事件。
            - `perf trace`：一个特殊的perf子命令，可以跟踪系统级别的系统调用。
            - `Ftrace`：Linux内置的跟踪器。
            - `BCC`：基于BPF的跟踪库和工具集。
            - `bpftrace`：基于BPF的跟踪器（bpftrace(8)）和工具集。
        - 系统级别的追踪器：
            - `strace(1)`：系统调用跟踪。
            - `gdb(1)`：代码级别的调试器。调试器能够检查每一个事件的开销，不适合在生产环境使用。
